import { NextApiRequest, NextApiResponse } from "next";
const snarkjs = require("snarkjs"); // used for performing zk-SNARK computations, it provides an implementation of zk-SNARKs in JavaScript
import fs from "fs";
import path from "path";

/* API endpoint that is responsible for verifying a zk-SNARK proof */
const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // if (req.method === "POST") {
  try {
    // construct the file path of the directory containing the ZKP files
    const directory = path.join(process.cwd(), "zkproof/prove-rep-v1");
    // construct the file path to the circuit.wasm file
    // circuit.wasm file is the compiled version of the circuit, saved in a WebAssembly (Wasm) binary format
    const circuitWasmPath = directory + "/circuit.wasm";
    // construct the full path of the circuit_final.zkey file
    // it's made by combining the base path to the directory containing the ZKP files + the relative path to the circuit_final.zkey file
    // circuit_final.zkey is the final public key that corresponds to the compiled WebAssembly binary of the zk-SNARK circuit, stored in the file circuit.wasm
    // this key is used to verify the proofs generated by the SNARK
    const circuitFinalZkeyPath = directory + "/circuit_final.zkey";
    // full path to the JSON file containing the verification key
    // it's used to verify the validity of the proof generated by the prover
    const verificationKeyJsonPath = directory + "/verification_key.json";

    // destructuring the properties of the request body and assigning to variables
    const { inputSignal, minValue, index, byteLength } = req.body;

    // create an object that will store the result of the proof verification process
    let result = { isVerified: false, message: "" };

    // Performs zk-SNARK proof verification using snarkjs library
    try {
      // the fullProve method of the snarkjs.groth16 generates a proof and public signals from the given circuit and input signals
      // the fullProve method takes 3 arguments:
      //    - an object containing: input_signal, min_value, index, and byte_length, these correspond to the values passed in the API request's body
      //    - circuitWasmPath: The path to the compiled WebAssembly binary of the zk-SNARK circuit
      //    - circuitFinalZkeyPath: The path to the final public key file that corresponds to the compiled circuit.
      const { proof, publicSignals } = await snarkjs.groth16.fullProve(
        {
          input_signal: inputSignal,
          min_value: minValue,
          index: index,
          byte_length: byteLength,
        }, // { input_signal: 43124, min_value: 168, index: 1, byte_length: 1 },
        circuitWasmPath,
        circuitFinalZkeyPath
      );
      // console.log("Proof: ", JSON.stringify(proof, null, 1));

      // Loads the verification key from the file system
      // used to verify the validity of the proof generated by the zk-SNARK circuit
      const vKey = JSON.parse(
        fs.readFileSync(verificationKeyJsonPath).toString()
      );

      // Verifies the proof generated from the fullProve function using the verification key stored in verificationKeyJsonPath
      // the verify method takes 3 arguments:
      //     - vKey: JSON object representing the verification key
      //     - publicSignals: array of public signals that were generated during the proof generation process
      //     - proof: zk-SNARK proof, which was obtained in the previous step of the code
      const verificationResult = await snarkjs.groth16.verify(
        vKey,
        publicSignals,
        proof
      );
      // Checks the result of the verification process
      if (verificationResult === true) {
        // Verification was successful
        result.isVerified = true;
        result.message = "Verification OK";
      } else {
        // Verification failed, proof is not valid
        result.isVerified = false;
        result.message = "Invalid proof";
      }
      // Returns the result object with a status code of 200 (OK)
      res.status(200).json(result);

      // Catch block to handle any errors from the fullProve and verify functions
    } catch (err: any) {
      result.isVerified = false;
      result.message = err.message;
      res.status(200).json(result);
      return;
    }

    // Catch block to handle any other errors
  } catch (err: any) {
    res.status(500).json({ statusCode: 500, message: err.message });
  }
  // } else {
  //   res.status(405).json({ error: "Method must be POST" });
  // }
};

export default handler;
